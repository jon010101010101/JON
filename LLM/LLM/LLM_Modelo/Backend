from flask import Flask, request, jsonify, render_template
from transformers import DistilBertTokenizer, DistilBertForSequenceClassification
import torch

# Cargar el modelo entrenado y el tokenizador
model = DistilBertForSequenceClassification.from_pretrained('./sentiment_model')
tokenizer = DistilBertTokenizer.from_pretrained('./sentiment_model')
model.eval()  # Configurar el modelo en modo evaluaci贸n

# Crear la aplicaci贸n Flask
app = Flask(__name__)

# Ruta principal para mostrar la interfaz web
@app.route('/')
def home():
    return render_template('index.html')  # Archivo HTML con la interfaz

# Ruta para procesar el texto ingresado por el usuario
@app.route('/predict', methods=['POST'])
def predict():
    # Obtener el texto enviado desde el frontend
    text = request.form['text']

    # Tokenizar el texto
    inputs = tokenizer.encode_plus(
        text,
        add_special_tokens=True,
        max_length=128,
        padding='max_length',
        truncation=True,
        return_tensors='pt'
    )

    # Realizar la predicci贸n con el modelo
    with torch.no_grad():
        outputs = model(inputs['input_ids'], attention_mask=inputs['attention_mask'])
        logits = outputs.logits
        predicted_class = torch.argmax(logits, dim=1).item()

    # Interpretar la clase predicha (0 = Negativo, 1 = Positivo)
    sentiment = "Positivo" if predicted_class == 1 else "Negativo"

    # Devolver el resultado como respuesta JSON
    return jsonify({'sentiment': sentiment})

# Ejecutar la aplicaci贸n Flask
if __name__ == '__main__':
    app.run(debug=True)
